{"version":3,"file":"event.js","sourceRoot":"","sources":["../src/event.ts"],"names":[],"mappings":";;;AAOa,QAAA,iBAAiB,GAAkB,mBAAmB,CAAA;AACtD,QAAA,iBAAiB,GAAkB,mBAAmB,CAAA;AAInE,MAAa,aAAa;IACxB,YAAoB,OAAqB;QAArB,YAAO,GAAP,OAAO,CAAc;IAAG,CAAC;IAE7C;;OAEG;IACH,KAAK,CAAC,OAAqB;QACzB,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE,OAAO,CAAC,CAAA;IAC5C,CAAC;IAED,QAAQ,CAAC,OAAqC;QAC5C,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,yBAAiB,EAAE,OAAO,CAAC,CAAA;IACtD,CAAC;IAED,gBAAgB,CAAC,OAA8C;QAC7D,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,yBAAiB,EAAE,OAAO,CAAC,CAAA;IACtD,CAAC;IAED,eAAe,CAAC,OAAmC;QACjD,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,kBAAkB,EAAE,OAAO,CAAC,CAAA;IACvD,CAAC;CACF;AArBD,sCAqBC;AAED,MAAM,UAAU,GAAG,KAAK,CAAA;AAExB,SAAS,UAAU,CAAC,OAAqB,EAAE,KAAoB,EAAE,OAAsC;IACrG,IAAI,UAAU,EAAE;QACd,OAAO,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,GAAG,IAAgB,EAAE,EAAE;YACxC,OAAO,CAAC,GAAG,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,CAAA;YACjC,OAAO,CAAC,GAAG,IAAI,CAAC,CAAA;QAClB,CAAC,CAAC,CAAA;KACH;SAAM;QACL,OAAO,CAAC,EAAE,CAAC,KAAK,EAAE,OAAO,CAAC,CAAA;KAC3B;AACH,CAAC","sourcesContent":["import { CancellationToken, PackageFileInfo, ProgressInfo, UpdateFileInfo, UpdateInfo } from \"builder-util-runtime\"\nimport { EventEmitter } from \"events\"\nimport { URL } from \"url\"\nimport { LoginCallback } from \"./electronHttpExecutor\"\n\nexport type UpdaterEvents = \"login\" | \"checking-for-update\" | \"update-available\" | \"update-cancelled\" | \"download-progress\" | \"update-downloaded\" | \"error\"\n\nexport const DOWNLOAD_PROGRESS: UpdaterEvents = \"download-progress\"\nexport const UPDATE_DOWNLOADED: UpdaterEvents = \"update-downloaded\"\n\nexport type LoginHandler = (authInfo: any, callback: LoginCallback) => void\n\nexport class UpdaterSignal {\n  constructor(private emitter: EventEmitter) {}\n\n  /**\n   * Emitted when an authenticating proxy is [asking for user credentials](https://github.com/electron/electron/blob/master/docs/api/client-request.md#event-login).\n   */\n  login(handler: LoginHandler): void {\n    addHandler(this.emitter, \"login\", handler)\n  }\n\n  progress(handler: (info: ProgressInfo) => void): void {\n    addHandler(this.emitter, DOWNLOAD_PROGRESS, handler)\n  }\n\n  updateDownloaded(handler: (info: UpdateDownloadedEvent) => void): void {\n    addHandler(this.emitter, UPDATE_DOWNLOADED, handler)\n  }\n\n  updateCancelled(handler: (info: UpdateInfo) => void): void {\n    addHandler(this.emitter, \"update-cancelled\", handler)\n  }\n}\n\nconst isLogEvent = false\n\nfunction addHandler(emitter: EventEmitter, event: UpdaterEvents, handler: (...args: Array<any>) => void): void {\n  if (isLogEvent) {\n    emitter.on(event, (...args: Array<any>) => {\n      console.log(\"%s %s\", event, args)\n      handler(...args)\n    })\n  } else {\n    emitter.on(event, handler)\n  }\n}\n\nexport interface UpdateCheckResult {\n  readonly updateInfo: UpdateInfo\n\n  readonly downloadPromise?: Promise<Array<string>> | null\n\n  readonly cancellationToken?: CancellationToken\n\n  /** @deprecated */\n  readonly versionInfo: UpdateInfo\n}\n\nexport interface ResolvedUpdateFileInfo {\n  readonly url: URL\n  readonly info: UpdateFileInfo\n\n  packageInfo?: PackageFileInfo\n}\n\nexport interface UpdateDownloadedEvent extends UpdateInfo {\n  downloadedFile: string\n}\n"]}