{"version":3,"file":"AppImageUpdater.js","sourceRoot":"","sources":["../src/AppImageUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import { AllPublishOptions, newError } from \"builder-util-runtime\"\nimport { execFileSync, spawn } from \"child_process\"\nimport { chmod } from \"fs-extra\"\nimport { unlinkSync } from \"fs\"\nimport * as path from \"path\"\nimport { DownloadUpdateOptions } from \"./AppUpdater\"\nimport { BaseUpdater, InstallOptions } from \"./BaseUpdater\"\nimport { DifferentialDownloaderOptions } from \"./differentialDownloader/DifferentialDownloader\"\nimport { FileWithEmbeddedBlockMapDifferentialDownloader } from \"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\"\nimport { DOWNLOAD_PROGRESS } from \"./main\"\nimport { findFile } from \"./providers/Provider\"\n\nexport class AppImageUpdater extends BaseUpdater {\n  constructor(options?: AllPublishOptions | null, app?: any) {\n    super(options, app)\n  }\n\n  public isUpdaterActive(): boolean {\n    if (process.env.APPIMAGE == null) {\n      if (process.env.SNAP == null) {\n        this._logger.warn(\"APPIMAGE env is not defined, current application is not an AppImage\")\n      } else {\n        this._logger.info(\"SNAP env is defined, updater is disabled\")\n      }\n      return false\n    }\n    return super.isUpdaterActive()\n  }\n\n  /*** @private */\n  protected doDownloadUpdate(downloadUpdateOptions: DownloadUpdateOptions): Promise<Array<string>> {\n    const provider = downloadUpdateOptions.updateInfoAndProvider.provider\n    const fileInfo = findFile(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"AppImage\")!\n    return this.executeDownload({\n      fileExtension: \"AppImage\",\n      fileInfo,\n      downloadUpdateOptions,\n      task: async (updateFile, downloadOptions) => {\n        const oldFile = process.env.APPIMAGE!\n        if (oldFile == null) {\n          throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n        }\n\n        let isDownloadFull = false\n        try {\n          const downloadOptions: DifferentialDownloaderOptions = {\n            newUrl: fileInfo.url,\n            oldFile,\n            logger: this._logger,\n            newFile: updateFile,\n            isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,\n            requestHeaders: downloadUpdateOptions.requestHeaders,\n            cancellationToken: downloadUpdateOptions.cancellationToken,\n          }\n\n          if (this.listenerCount(DOWNLOAD_PROGRESS) > 0) {\n            downloadOptions.onProgress = it => this.emit(DOWNLOAD_PROGRESS, it)\n          }\n\n          await new FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions).download()\n        } catch (e) {\n          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\n          // during test (developer machine mac) we must throw error\n          isDownloadFull = process.platform === \"linux\"\n        }\n\n        if (isDownloadFull) {\n          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions)\n        }\n\n        await chmod(updateFile, 0o755)\n      },\n    })\n  }\n\n  protected doInstall(options: InstallOptions): boolean {\n    const appImageFile = process.env.APPIMAGE!\n    if (appImageFile == null) {\n      throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n    }\n\n    // https://stackoverflow.com/a/1712051/1910191\n    unlinkSync(appImageFile)\n\n    let destination: string\n    const existingBaseName = path.basename(appImageFile)\n    // https://github.com/electron-userland/electron-builder/issues/2964\n    // if no version in existing file name, it means that user wants to preserve current custom name\n    if (path.basename(options.installerPath) === existingBaseName || !/\\d+\\.\\d+\\.\\d+/.test(existingBaseName)) {\n      // no version in the file name, overwrite existing\n      destination = appImageFile\n    } else {\n      destination = path.join(path.dirname(appImageFile), path.basename(options.installerPath))\n    }\n\n    execFileSync(\"mv\", [\"-f\", options.installerPath, destination])\n    if (destination !== appImageFile) {\n      this.emit(\"appimage-filename-updated\", destination)\n    }\n\n    const env: any = {\n      ...process.env,\n      APPIMAGE_SILENT_INSTALL: \"true\",\n    }\n\n    if (options.isForceRunAfter) {\n      spawn(destination, [], {\n        detached: true,\n        stdio: \"ignore\",\n        env,\n      }).unref()\n    } else {\n      env.APPIMAGE_EXIT_AFTER_INSTALL = \"true\"\n      execFileSync(destination, [], { env })\n    }\n    return true\n  }\n}\n"]}